[title=MERLIN - transformation macros]
[Back to index](#s=MERLIN/doc/index)  

## Transformation macros

MERLIN provides a number of macros to use for transformations. If you don't know what bullet transformations are, you should check out [this page](#s=modding/transforms).

### How it works
MERLIN defines a whole bunch of inline functions for every transformation to make them easier to use. There also exist globaldefs for transformation type IDs, but they are meant for internal use and may be changed in the future without any warnings. Because of that, the inline functions should be used instead.

[requireEclmap=17]
### The table
The following table contains all known transformations, although some of them are still WIP and need checking facts. As of now, take everything written here with a grain of salt. **VERY IMPORTANT, READ THIS**: Every transform has (at least) 2 different inline functions, 1 for [ins=609,13] and 1 for [ins=611,13]. All functions follow the same naming convention, so for example `etExSpeedUp` is for [ins=611,13] and `etExSpeedUpSet` is for [ins=609,13].

| ID        | Inline function                                                          | Description                                                |
|:---------:|:-------------------------------------------------------------------------|:-----------------------------------------------------------|
| 1         | [code]etExSpeedUp(int et, int isAsync)[/code] [br] [code]etExSpeedUpSet(int et, int slot int isAsync)[/code]| Make the bullet move really fast for a short amount of time. More precisely, it makes the bullet move at a speed `10.0f` faster than its normal speed for 15 frames (or something similar to that, it was measured based on screenshots by Dai). |
| 2         | [code]etExAnim(int et, int isAsync, int anim)[/code] [br] [code]etExAnimSet(int et, int slot, int isAsync, int anim)[/code] | Make the bullet play a "fog" effect, typically used as the first transform to animate bullet spawning. It seems like there are 3 unique effects, `0`, `1` and `2`, each of them lasts longer and spawns a bigger animation than the previous one. |
| 4         | [code]etExAccel(int et, int isAsync, int time, float spd, float ang)[/code] [br] [code]etExAccelSet(int et, int slot, int isAsync, int time, float spd, float ang)[/code] | Make the bullet accelerate by `spd` per frame in direction `ang` for `time` frames. `ang` can be `NEGF` to use bullet's current movement angle. |
| 8         | [code]etExAngleAccel(int et, int isAsync, int time, float spd, float angVel)[/code] [br] [code]etExAngleAccelSet(int et, int slot, int isAsync, int time, float spd, float angVel)[/code] | For `time` frames, bullet acceleration is set to `spd` (acceleration angle is the same as bullet's current movement angle) and angular velocity is set to `angVel`. |
| 8         | [code]etExAngleAccelLaser(int et, int isAsync, int a, int b, float r, float s)[/code] [br] [code]etExAngleAccelLaserSet(int et, int slot, int isAsync, int time, int b, float r, float s)[/code] | Same as above, but takes 1 additional parameter that's supposedly used by lasers, needs investigation. |
| 16        | [code]etExStep(int et, int isAsync, int time, int cnt, int type, float r, float s)[/code] [br] [code]etExStepSet(int et, int slot, int isAsync, int time, int cnt, int type, float r, float s)[/code] | In `time` frames, the bullet will slow down to 0 speed and get angle/speed modification based on `type`, `r` and `s`. This is repeated `cnt` times. For a more in-depth description, check the `etExStep` table below. |
| 32        | - | Unknown... |
| 64        | [code]etExBounce(int et, int isAsync, int cnt, int walls, float newSpd)[/code] [br] [code]etExBounceSet(int et, int slot, int isAsync, int cnt, int walls, float newSpd)[/code] | Allow the bullet to bounce off the edges of the screen `cnt` times. The edges it's allowed to bounce off are specified by the `walls` parameter (refer to constants [here](#s=MERLIN/doc/globals/etama-etc)). The speed after the bounce will be set to `newSpd`, or kept as-is if `newSpd` is `NEGF`. The transformations after this one won't be executed until the bullet bounces the given amount of times. Therefore, this can be used to detect when the bullet reaches the edge of the screen. |
| 64        | [code]etExBounceCustom(int et, int isAsync, int cnt, int walls, float newSpd, float x, float y)[/code] [br] [code]etExBounceCustomSet(int et, int slot, int isAsync, int cnt, int walls, float newSpd, float x, float y)[/code] | Same as above, but the point at which the bullets bounce can be modified with the `x` and `y` parameters - `x` specifies the distance from left/right edge of the screen where the bullets will bounce, and `y` specifies the distance from top/bottom edge of the screen. |
| 128        | [code]etExInvuln(int et, int isAsync, int time)[/code] [br] [code]etExInvulnSet(int et, int slot, int isAsync, int time)[/code] | Makes the bullet invulnerable to bombs for `time` frames. Does NOT stop the next transformation from executing for the duration of invulnerability. |
| 256        | [code]etExOffscreen(int et, int isAsync, int time, int b)[/code] [br] [code]etExOffscreenSet(int et, int slot, int isAsync, int time, int b)[/code] | Makes the bullet not delete when offscreen for `time` frames. Effect of `b` is unknown, although there is a pretty large amount of code at `th17.exe+1961b` that does... something if it's nonzero. It seems to be related to some ANM stuff. If anyone figures it out, let me know. Also, this transform does NOT stop the next transformation from executing for the duration of the effect.
| 512        | [code]etExSprite(int et, int isAsync, int type, int color)[/code] [br] [code]etExSpriteSet(int et, int slot, int isAsync, int a, int b)[/code] | Change the bullet sprite (and use the corresponding hitbox). `type` and `color` are the same as in [ins=602,17]. |
| 1024       | [code]etExDelete(int et, int isAsync, int eff)[/code] [br] [code]etExDeleteSet(int et, int slot, int isAsync, int eff)[/code] | Deletes the bullet. There are 2 different delete animations that can be used, use the `eff` parameter to choose which (either `0` or `1`). |
| 2048       | [code]etExSound(int et, int isAsync, int id)[/code] [br] [code]etExSoundSet(int et, int slot, int isAsync, int a)[/code] | Play the given sound, IDs are the same as for [ins=516,17]. Refer to the [sound effect table](#s=MERLIN/doc/globals/sfx). |
| 4096       | [code]etExWrap(int et, int isAsync, int cnt, int walls, float newSpd)[/code] [br] [code]etExWrapSet(int et, int slot, int isAsync, int a, int b, float r)[/code] | Same as `etExBounce`, but instead of bouncing the bullet will wrap to the other side of the screen. |
| 8192       | [code]etExShootPrep(int et, int isAsync, int aim, int transformIndex, int cnt1, int cnt2, float ang1, float ang2, float spd1, float spd2)[/code] [br] [code]etExShootPrepSet(int et, int slot, int isAsync, int aim, int transformIndex, int cnt1, int cnt2, float ang1, float ang2, float spd1, float spd2)[/code] | 1st part of the bullet spawning transformation. Sets the bullet manager properties that will be used to shoot bullets. `ang1` can be set to `NEGF` to use the angle of the bullet that runs the transformation as `ang1`. The spawned bullets will use the same `etEx` list as this one, except they'll start from index given by `transformIndex`. This transform requires using `etExShoot` right after it to actually shoot the bullets. |
| 16384      | [code]etExShoot(int et, int isAsync, int type, int color, int delete, int eff)[/code] [br] [code]etExShootSet(int et, int slot, int isAsync, int type, int color, int delete, int eff)[/code] | 2nd part of the bullet spawning transformation. Sets the sprite type/color (same as [ins=602,17]) of the spawned bullets. If `delete` is nonzero, the bullet that runs this transformation will be deleted, and an animation based on `eff` will play (same as in `etExDelete`). This transform requires using `etExShootPrep` right before it to define the rest of properties. |
| 134217728  | [code]etExShootLaserPrep(int et, int isAsync, int a, int b, int c, int d, float r, float s, float m, float n)[/code] [br] [code]etExShootLaserSetPrep(int et, int slot, int isAsync, int a, int b, int c, int d, float r, float s, float m, float n)[/code] | Similar to `etExShootPrep` but for lasers, needs investigation. |
| 16384      | [code]etExShootLaser(int et, int isAsync, int a, int b, int c, int d, float r, float s, float m, float n)[/code] [br] [code]etExShootLaserSet(int et, int slot, int isAsync, int a, int b, int c, int d, float r, float s, float m, float n)[/code] | Version of `etExShoot` that takes more parameters, intended to be used to shoot lasers combined with `etExShootLaserPrep`, needs investigation. |
| 32768      | - | This works differently in like every game lmao, needs investigation. |
| 65536      | [code]etExJump(int et, int isAsync, int index, int cnt)[/code] [br] [code]etExJumpSet(int et, int slot, int isAsync, int index, int cnt)[/code] | Jump to transformation at the given index, typically used for loops. `cnt` determines the maximum amount of times this transformation can execute. |
| 131072     | [code]etExMove(int et, int isAsync, int time, int mode, float x, float y)[/code] [br] [code]etExMoveSet(int et, int slot, int isAsync, int time, int mode, float x, float y)[/code] | In `time` frames using mode `mode`, move the bullet to absolute position `(x,y)`. For the duration of the movement, bullet's normal movement gets disabled. After the movement finishes, the original speed is restored, but the bullet keeps the angle it used when moving from its position before the transformation to the position `(x,y)`. I have no idea what kind of hilariously broken effects you may get when trying to use this with some other transform at once by using the `isAsync` flag. |
| 262144     | [code]etExVel(int et, int isAsync, float ang, float spd)[/code] [br] [code]etExVelSet(int et, int slot, int isAsync, float ang, float spd)[/code] | Immediately change bullet angle to `ang` and bullet speed to `spd`. `ang` can be set to `NEGF` to keep current angle, and `spd` can be set to `NEGF` to set current speed. If both are set to `NEGF`, the transform won't do anything. Wowie! |
| 524288     | [code]etExVelAdd(int et, int isAsync, int a, float ang, float spd)[/code] [br] [code]etExVelAddSet(int et, int slot, int isAsync, int a, float ang, float spd)[/code] | Apply velocity in direction `ang` and speed `spd` to the bullet. Effect of `a` is unknown, setting it to `0` is known to freeze the game. This transform needs investigation. |
| 1048576    | [code]etExBright(int et, int isAsync, int type)[/code] [br] [code]etExBrightSet(int et, int slot, int isAsync, int type)[/code] | Set bullet brightness effect based on `type`. `0` is no effect, `1` is glowing and `2` is darkness. |
| 2097152    | [code]etExAccelWeird(int et, int isAsync, int time, float spd, float ang)[/code] [br] [code]etExAccelWeirdSet(int et, int slot, int isAsync, int time, float spd, float ang)[/code] | Make the bullet accelerate in direction `ang` for `time` frames. The value of acceleration is `(spd - currBulletSpeed) / time`. |
| 4194304    | [code]etExSize(int et, int isAsync, int time, int mode, float sizeFrom, float sizeTo)[/code] [br] [code]etExSizeSet(int et, int slot, int isAsync, int time, int mode, float sizeFrom, float sizeTo)[/code] | In `time` frames using mode `mode`, change bullet size from `sizeFrom` to `sizeTo`. This changes both the sprite and the hitbox. |
| 8388608    | [code]etExSave(int et, int isAsync)[/code] [br] [code]etExSaveSet(int et, int slot, int isAsync)[/code] | Save current angle to player and current coordinates of the bullet. These stored values can be used with some functionalities of `etExStep`. |
| 16777216   | [code]etExEnmCreate(int et, int isAsync)[/code] [br] [code]etExEnmCreateSet(int et, int slot, int isAsync)[/code] | Spawn an enemy using the sub set by [ins=640,17]. If no sub was set, game will explode. |
| 33554432   | [code]etExLayer(int et, int isAsync, int layer)[/code] [br] [code]etExLayerSet(int et, int slot, int isAsync, int layer)[/code] | Change bullet's layer based on `layer`. TODO: check if it increments current layer or sets it directly. |
| 67108864   | [code]etExDelay(int et, int isAsync, int time)[/code] [br] [code]etExDelaySet(int et, int slot, int isAsync, int time)[/code] | Hide the bullet for `time` frames. During this time, it will not move, will be invisible and won't have a hitbox. If used as a first transformation, can be used to delay when the bullet actually appears. |
| 536870912  | [code]etExHitbox(int et, int isAsync, float r)[/code] [br] [code]etExHitboxSet(int et, int slot, int isAsync, float r)[/code] | Change the bullet hitbox to original hitbox multiplied by `r`. If `r` is `0.0f` the hitbox will be completely disabled, `-1.0f` restores original hitbox. Wait, is this actually correct? TODO: check |
| -2147483648| [code]etExWait(int et, int isAsync, int time)[/code] [br] [code]etExWaitSet(int et, int slot, int isAsync, int time)[/code] | Wait for `time` frames before moving to the next transformation. |
[/requireEclmap]

[Back to index](#s=MERLIN/doc/index)  